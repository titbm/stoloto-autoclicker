# Режимы поиска билетов

## Обзор

Расширение "Столото Автокликер" поддерживает три режима поиска билетов, каждый из которых использует различную логику для определения соответствия билета заданным критериям. Все режимы реализованы в функции `analyzeTicket()` в файле `content.js`.

## Структура билета

Каждый билет Русского лото состоит из 6 строк по 9 чисел в каждой:

```
Строка 1: [  5] [ 12] [   ] [ 34] [   ] [ 56] [   ] [ 78] [   ]
Строка 2: [   ] [ 13] [ 25] [   ] [ 45] [   ] [ 67] [   ] [ 89]
Строка 3: [  7] [   ] [ 26] [ 37] [   ] [ 58] [   ] [ 79] [   ]
Строка 4: [   ] [ 14] [   ] [ 38] [ 49] [   ] [ 68] [   ] [ 90]
Строка 5: [  8] [   ] [ 27] [   ] [ 50] [ 59] [   ] [ 80] [   ]
Строка 6: [   ] [ 15] [   ] [ 39] [   ] [ 60] [ 69] [   ] [ 81]
```

- Всего в билете 45 чисел (по 15 в каждой строке, но только 5 чисел в строке заполнены)
- Числа располагаются в диапазоне от 1 до 90
- Первая половина билета: строки 1-3
- Вторая половина билета: строки 4-6

## Режимы поиска

### 1. Режим "anywhere" - Поиск в любом месте билета

**Описание**: Ищет все указанные числа в любом месте билета, независимо от их расположения.

**Логика работы**:
```javascript
case 'anywhere': {
    const allFound = numbers.every(num => ticketNumbers.includes(parseInt(num)));
    if (allFound) console.log('✅ Все числа найдены в билете!');
    return allFound;
}
```

**Алгоритм**:
1. Извлекает все числа из билета в один массив `ticketNumbers`
2. Проверяет, что каждое искомое число присутствует в билете
3. Возвращает `true`, если все числа найдены

**Пример использования**:
- Поисковые числа: [5, 25, 45, 65]
- Билет содержит эти числа в разных строках → **Найден**
- Билет не содержит число 65 → **Не найден**

### 2. Режим "half" - Поиск в одной половине билета

**Описание**: Ищет все указанные числа либо в верхней половине (строки 1-3), либо в нижней половине (строки 4-6) билета.

**Логика работы**:
```javascript
case 'half': {
    // Первая половина - первые три строки
    const firstHalf = rows.slice(0, 3)
        .flat()
        .map(num => parseInt(num.textContent.trim()))
        .filter(num => !isNaN(num));

    // Вторая половина - последние три строки
    const secondHalf = rows.slice(3)
        .flat()
        .map(num => parseInt(num.textContent.trim()))
        .filter(num => !isNaN(num));

    // Проверяем, все ли указанные числа находятся в первой половине
    const allInFirstHalf = numbers.every(num => firstHalf.includes(parseInt(num)));
    // Проверяем, все ли указанные числа находятся во второй половине
    const allInSecondHalf = numbers.every(num => secondHalf.includes(parseInt(num)));

    return allInFirstHalf || allInSecondHalf;
}
```

**Алгоритм**:
1. Разделяет билет на две половины:
   - Первая половина: строки 1-3
   - Вторая половина: строки 4-6
2. Извлекает числа из каждой половины отдельно
3. Проверяет, все ли искомые числа находятся в первой половине
4. Проверяет, все ли искомые числа находятся во второй половине
5. Возвращает `true`, если все числа найдены в любой из половин

**Пример использования**:
- Поисковые числа: [5, 12, 25]
- Числа 5 и 12 в строках 1-3, число 25 в строке 2 → **Найден** (все в первой половине)
- Число 5 в строке 1, числа 12 и 25 в строках 4-6 → **Не найден** (числа в разных половинах)

### 3. Режим "row" - Поиск в одной строке билета

**Описание**: Ищет все указанные числа в одной строке билета.

**Логика работы**:
```javascript
case 'row': {
    // Проверяем каждую строку
    for (const row of rows) {
        const rowNumbers = row
            .map(num => parseInt(num.textContent.trim()))
            .filter(num => !isNaN(num));
            
        const allInRow = numbers.every(num => rowNumbers.includes(parseInt(num)));
        if (allInRow) {
            console.log('✅ Все числа найдены в одной строке!');
            return true;
        }
    }
    return false;
}
```

**Алгоритм**:
1. Перебирает каждую строку билета (всего 6 строк)
2. Для каждой строки извлекает все числа
3. Проверяет, все ли искомые числа присутствуют в текущей строке
4. Возвращает `true` при первом совпадении
5. Если ни одна строка не содержит все числа, возвращает `false`

**Пример использования**:
- Поисковые числа: [12, 25, 45]
- Строка 2 содержит числа [13, 25, 45, 67, 89] → **Не найден** (нет числа 12)
- Строка 3 содержит числа [7, 12, 25, 37, 45] → **Найден** (все числа в одной строке)

## Функция analyzeTicket()

### Сигнатура функции
```javascript
function analyzeTicket(ticket, numbers)
```

### Параметры
- `ticket` - DOM элемент билета
- `numbers` - массив искомых чисел

### Возвращаемое значение
- `true` - билет соответствует критериям поиска
- `false` - билет не соответствует критериям

### Общий алгоритм работы

1. **Извлечение структуры билета**:
   ```javascript
   const allNumbers = Array.from(ticket.querySelectorAll('[data-test-id="number"], [data-test-id="selected-number"]'));
   
   // Группируем числа по 9 (в каждой строке по 9 чисел)
   const rows = [];
   for (let i = 0; i < allNumbers.length; i += 9) {
       rows.push(allNumbers.slice(i, i + 9));
   }
   ```

2. **Валидация структуры**:
   ```javascript
   if (rows.length !== 6) {
       console.log('Неверное количество строк в билете');
       return false;
   }
   ```

3. **Проверка исключаемых чисел**:
   ```javascript
   // Получаем все числа из билета
   const ticketNumbers = rows
       .flat()
       .map(num => parseInt(num.textContent.trim()))
       .filter(num => !isNaN(num));

   // Проверяем, нет ли исключаемых чисел в билете
   if (excludeNumbers.length > 0) {
       const hasExcluded = excludeNumbers.some(num => ticketNumbers.includes(parseInt(num)));
       if (hasExcluded) {
           console.log('❌ В билете найдены исключаемые числа');
           return false;
       }
   }
   ```

4. **Применение режима поиска**: В зависимости от значения `searchMode`, выполняется соответствующая логика поиска.

## Процедуры валидации

### Валидация структуры билета
- Проверка наличия ровно 6 строк
- Проверка наличия 9 позиций в каждой строке
- Валидация селекторов DOM элементов

### Валидация чисел
- Проверка корректности парсинга чисел из DOM
- Фильтрация некорректных значений (NaN)
- Проверка диапазона чисел (1-90)

### Валидация исключений
- Проверка наличия исключаемых чисел в билете
- Приоритет исключений над поиском

## Логирование и отладка

Функция `analyzeTicket()` включает подробное логирование для отладки:

```javascript
console.log('Анализ билета:', ticket.querySelector('[data-test-id="ticket-number"]')?.textContent);
console.log('Числа в первой половине:', firstHalf);
console.log('Числа во второй половине:', secondHalf);
console.log('✅ Все числа найдены в одной строке!');
console.log('❌ В билете найдены исключаемые числа');
```

## Производительность

- Функция оптимизирована для быстрого анализа большого количества билетов
- Использует раннее завершение при обнаружении исключаемых чисел
- Минимизирует количество DOM операций через кэширование элементов

## Интеграция с поиском

Функция `analyzeTicket()` вызывается в цикле поиска билетов:

```javascript
for (const ticket of tickets) {
    if (!isSearching) return false;
    ticketsChecked++;
    
    updateStatusBlock(numbers, excludeNumbers, mode);
    
    if (analyzeTicket(ticket, numbers)) {
        const ticketNumber = ticket.querySelector('[data-test-id="ticket-number"]')?.textContent || 'неизвестен';
        console.log('🎯 Найден подходящий билет:', ticketNumber);
        foundTicketsOnPage.push(ticket);
    }
}
```